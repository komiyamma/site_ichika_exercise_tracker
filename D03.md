# 🌟 第3章：フォームと表示エリアの最小ループを体験しよう

* **内容** ：単一フォームと追加ボタンを使って、入力したデータを画面にどんどん表示する最小構成を、リスト表示とテーブル表示の2パターンで体験します。さらに「新しい記録を上に出したい」という課題に出会い、タイムスタンプとソートで改善する流れも追います。
* **目的** ：`localStorage` に触れる前段階として、フォーム送信 → 表示エリア更新という一連の流れを自力で再現できるようにします。

---

## 🔍 3.1 ゴールの確認

今回のゴールはとてもシンプルです。

1. フォーム項目は 1 つだけ（今回は運動メモのテキストを扱います）。
2. 「追加」ボタンを押すと、その内容を **表示エリア** に追加します（まずは末尾に積み上げ、課題に気づいたら並べ替えます）。
3. 何度押しても履歴が消えず、画面上に追加され続けます。

これができれば、「入力 → 画面表示」の基本サイクルが完成し、第4章・第5章で要件を広げる土台になります。

---

## 🧠 3.2 初学者の悩み

「フォームの値をどうやって取り出すの？」「ボタンを押したら何が起こるの？」という疑問が最初に浮かびます。  
ここでは HTML が読み込まれたら最初に呼ばれる **セットアップ関数** と、**フォーム送信を処理する関数** の 2 本立てで構成します。`script.js` でも同じ発想（`initializePage` → `handleFormSubmit`）なので、ぴったりの練習になります。

---

## 🧪 3.3 ハンズオン：ミニサンプルを動かす

### HTML

```html
<h2>ミニ運動メモ</h2>
<form id="memo-form">
  <label for="memo" class="required">メモ</label>
  <input id="memo" type="text" required placeholder="例: 腕立て伏せ 10 回">
  <button type="submit">追加</button>
</form>

<h3>きょうのメモ</h3>
<ul id="memo-list"></ul>
```

ポイントは「フォームは 1 つ」「表示エリア（ここでは `<ul>`）の末尾へ積み上げる」という構成です。  
`class="required"` は既存 UI と合わせて、入力必須であることを視覚的に示します。

### JavaScript

```javascript
document.addEventListener('DOMContentLoaded', setupMemoForm);

function setupMemoForm() {
  const form = document.getElementById('memo-form');
  form.addEventListener('submit', handleMemoSubmit);
}

function handleMemoSubmit(event) {
  event.preventDefault(); // ページ遷移を防ぐ

  const memoInput = document.getElementById('memo');
  const memoList = document.getElementById('memo-list');

  const text = memoInput.value.trim();
  if (text === '') {
    return;
  }

  const item = document.createElement('li');
  item.textContent = text;
  memoList.appendChild(item);

  memoInput.value = '';
  memoInput.focus();
}
```

* **`DOMContentLoaded`** ：HTML の読み込み完了後に `setupMemoForm` を呼び出すことで、DOM がまだ存在しないタイミングを避けられます。
* **`setupMemoForm`** ：フォームを取得してイベントを登録するだけの関数。役割が一目で分かります。
* **`handleMemoSubmit`** ：送信時の処理をまとめた関数。`script.js` の `handleFormSubmit` と並べて読めば、どちらも「入力を取り出す → 要素を足す」という流れになっていることが分かります。
* **`appendChild`** ：新しく作った `<li>` を表示エリアの末尾に追加します。

> ❗ メモ：`event.preventDefault()` は「フォームが送信されたときの標準の動き（ページの再読み込みや、サーバーへのデータ送信）を止める」ための 1 行です。`<form>` タグは本来、入力内容をサーバーに送って別ページを開き直すのが仕事なので、そのまま送信すると画面がリセットされてしまいます。この教材ではブラウザ内で完結させたいので、いったん標準の動きを止めてから JavaScript 側でデータ追加や表示更新を行っています。試しにこの 1 行をコメントアウトしてみると、ボタンを押した瞬間にページが更新される様子が確認できます。

これで「入力 → 表示」を繰り返す最小ループが完成します。

### テーブル版も試そう

本番アプリでは `<table>` を使って記録を整然と並べます。ここでも 1 列だけの最小テーブルを用意して、フォーム送信ごとに末尾へ行を追加してみましょう。まずは「入力順に下へ積み上がる」挙動を素直に体験します。

```html
<h2>テーブル版メモ</h2>
<form id="table-memo-form">
  <label for="table-memo" class="required">メモ</label>
  <input id="table-memo" type="text" required placeholder="例: スクワット 15 回">
  <button type="submit">追加</button>
</form>

<table>
  <thead>
    <tr>
      <th>メモ内容</th>
    </tr>
  </thead>
  <tbody id="table-memo-body"></tbody>
</table>
```

```javascript
document.addEventListener('DOMContentLoaded', setupTableMemo);

const tableEntries = [];

function setupTableMemo() {
  const tableForm = document.getElementById('table-memo-form');
  tableForm.addEventListener('submit', handleTableMemoSubmit);
  renderTableMemo();
}

function handleTableMemoSubmit(event) {
  event.preventDefault();

  const memoInput = document.getElementById('table-memo');
  const text = memoInput.value.trim();
  if (text === '') {
    return;
  }

  tableEntries.push(text);
  renderTableMemo();

  memoInput.value = '';
  memoInput.focus();
}

function renderTableMemo() {
  const tableMemoBody = document.getElementById('table-memo-body');

  let tableHtml = '';
  for (const entry of tableEntries) {
    tableHtml += `
      <tr>
        <td>${entry}</td>
      </tr>
    `;
  }

  tableMemoBody.innerHTML = tableHtml;
}
```

`setup → submit ハンドラ → render` の 3 つに分けることで、「最初にイベントを登録する」「データを配列に貯める」「画面表示は専用関数に任せる」という流れが見やすくなりました。ここでは単純に `push` したものをそのまま描画しているため、入力順に下へ積み上がります。

### 🔄 並び順でぶつかった壁と改良案

リストとテーブルを動かしていると、すぐにこんな疑問が出てきます。

> 「さっき追加したばかりのメモが表の下にあって見つけづらい……。上から見たいな」

そこで、保存した瞬間の時間をデータに含めておき、描画前に並び替えてみましょう。

`createdAt` というフィールドには `Date.now()` の戻り値を入れます。これは「 **1970 年 1 月 1 日 00:00:00 UTC からの経過ミリ秒** 」を表すただの数値で、時間が進むほど必ず大きくなります。そのため `b.createdAt - a.createdAt` のように差を取れば、より新しい記録ほど大きい値を持っていることを利用して簡単に並べ替えられます。

```html
<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>第3章：フォーム最小ループ（テーブル版）</title>
    <style>
      body {
        font-family: sans-serif;
        margin: 24px;
        max-width: 680px;
      }

      form,
      table {
        margin-bottom: 24px;
      }

      table {
        border-collapse: collapse;
        width: 100%;
      }

      th,
      td {
        border: 1px solid #888;
        padding: 8px;
        text-align: left;
      }

      .required::after {
        content: " *";
        color: #c00;
      }
    </style>
  </head>
  <body>
    <h1>第3章：フォーム最小ループ（テーブル版）</h1>

    <form id="table-memo-form">
      <label for="table-memo" class="required">メモ</label>
      <input id="table-memo" type="text" required placeholder="例: スクワット 15 回">
      <button type="submit">追加</button>
    </form>

    <table>
      <thead>
        <tr>
          <th>メモ内容</th>
          <th>記録時刻</th>
        </tr>
      </thead>
      <tbody id="table-memo-body"></tbody>
    </table>

    <script>
      document.addEventListener('DOMContentLoaded', setupTableMemo);

      const tableEntries = [];

      function setupTableMemo() {
        const tableForm = document.getElementById('table-memo-form');
        tableForm.addEventListener('submit', handleTableMemoSubmit);
        renderTableMemo();
      }

      function handleTableMemoSubmit(event) {
        event.preventDefault();

        const memoInput = document.getElementById('table-memo');
        const text = memoInput.value.trim();
        if (text === '') {
          return;
        }

        tableEntries.push({
          text,
          createdAt: Date.now(),
        });
        renderTableMemo();

        memoInput.value = '';
        memoInput.focus();
      }

      function renderTableMemo() {
        const tableMemoBody = document.getElementById('table-memo-body');

        const sortedEntries = tableEntries.toSorted((a, b) => b.createdAt - a.createdAt);

        let tableHtml = '';
        for (const entry of sortedEntries) {
          tableHtml += `
            <tr>
              <td>${entry.text}</td>
              <td>回数とか日付とかとにかく他の項目!!</td>
            </tr>
          `;
        }

        tableMemoBody.innerHTML = tableHtml;
      }
    </script>
  </body>
</html>
```

`setup → submit ハンドラ → render` の 3 つに分けることで、「最初にイベントを登録する」「データを配列に貯める」「画面表示は専用関数に任せる」という流れが見やすくなりました。最初に作った素朴なバージョンでは `push` した順に下へ積み上がり、最新が見つけづらくなる課題が出てきます。そこで `createdAt` を持たせて `toSorted` で新しい順に並べ替える改善を加えました。`script.js` の `createdAt` と `filteredEntries.sort(...)` もまさにこの考え方です。

---

## 🧭 3.4 先を見据えた観察ポイント

* 今はブラウザを更新するとメモが消えます。第2章で理解した **`localStorage`** を組み合わせれば永続化できることに気づけるはずです。
* `<li>` や `<tr>` をよりリッチにしたり、削除ボタンを付けたり、といった拡張が後の章で登場します。まずは「画面に溜まり続ける仕組み」を体験し、そこから並び順の課題に気づいて改善案を考えるのが大切です。
* `script.js` 本編では、フォーム項目が複数あり、テーブル表示やフィルター処理が追加されています。今回のミニサンプルで「並び替えを意識した表示」に触れたことで、最終版での `createdAt` と `sort` の組み合わせも理解しやすくなります。

---

## ✅ 3.5 まとめ

1. フォーム → 画面表示の最小ループを自力で組み立てた。
2. `DOMContentLoaded` や `preventDefault()` といった定番パターンを体験した。
3. 今後必要になる拡張（複数項目、永続化、削除機能、並び替え）をイメージできるようになった。

この第3章で手応えをつかめば、「フォームが多くなっても、保存が絡んでも大丈夫」と自信を持って第4章・第5章へ進めます！
