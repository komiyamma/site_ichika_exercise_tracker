# refactor/ 以下のテストコードに関する課題管理

`__tests__/` 以下のテストコードは総じて高品質であり、アプリケーションの正当性を担保する上で十分に機能しています。
しかし、プロフェッショナルの視点から、より堅牢で保守性の高いテストスイートを目指すためのいくつかの改善点を以下に示します。

## 1. ControllerテストにおけるMockの肥大化 (WorkoutController.test.js)

**現状:**
`WorkoutController.test.js` では、`MockService` と `MockView` がテストファイル内で定義されています。これらのモックは、実際のクラスの多くの振る舞いを再実装しており、特に `MockService` は簡易的なインメモリデータベースとして機能しています。

**課題:**
- **テストの関心事の混在:** Controllerのテストであるにもかかわらず、Serviceのロジック（バリデーションやデータ操作）の再実装に多くのコードを費やしており、テストの焦点がぼやけています。
- **保守性の低下:** ServiceやViewの実装が変更された場合、テスト内のモックも追従して修正する必要があり、二重のメンテナンスコストが発生します。
- **可読性の低下:** テストコード本体よりもモックの記述が長くなっており、テストの意図を把握しにくくなっています。

**提案:**
- **スパイ/スタブの活用:** `vi.spyOn` や `vi.fn()` を活用し、ServiceやViewのメソッド呼び出しを監視・スタブ化するに留めます。これにより、モックの実装を大幅に削減し、Controllerが「正しいメソッドを正しい引数で呼び出しているか」という責務に集中したテストを記述できます。
- **テストデータ生成の分離:** テストデータの生成ロジックをテストファイルから分離し、テストデータファクトリのような共通モジュールに切り出すことで、テストの可読性を向上させます。

## 2. ViewテストにおけるDOM構造への強い依存 (WorkoutView.test.js)

**現状:**
`WorkoutView.test.js` では、`document.getElementById` をモック化し、ハードコードされたID (`entry-form`, `list` など) を持つ仮想的なDOM要素を返却しています。

**課題:**
- **脆いテスト:** HTMLのIDやクラス名が変更されると、テストは即座に失敗します。これはリファクタリングを妨げる要因となります。
- **テストの信頼性:** テストは実際のDOM構造ではなく、モック化されたオブジェクトのプロパティを検証しているに過ぎません。実際のブラウザ環境で正しくレンダリング・動作することを保証するものではありません。

**提案:**
- **Testing Libraryの導入:** `@testing-library/dom` のようなライブラリを導入し、`getByRole`, `getByLabelText` といった、よりユーザーの視点に近いセレクタを利用してDOM要素を取得するように変更します。これにより、HTMLの具体的な実装からの分離が促進され、リファクタリング耐性が向上します。
- **JSDOM環境の活用:** Vitestのテスト環境を `jsdom` に設定することで、より実際のブラウザに近い環境でDOM操作のテストを実行できます。これにより、`document.createElement` などの挙動を細かくモックする必要がなくなります。

## 3. Repositoryテストの実行環境依存 (WorkoutRepository.test.js)

**現状:**
`WorkoutRepository.test.js` は、テスト実行環境に存在する `localStorage` APIに直接依存しています。

**課題:**
- **実行環境の制約:** `localStorage` が利用できない環境（例えば、特定のサーバーサイドランタイムなど）では、このテストは実行できません。
- **テストの分離性:** グローバルな `localStorage` オブジェクトを共有しているため、他のテスト（あるいは将来追加されるテスト）が `localStorage` を使用する場合、テスト間で状態が干渉し、予期せぬ失敗を引き起こす可能性があります。
- **パフォーマンス:** ファイルI/O（`localStorage` の実体は多くの場合ディスク上のファイル）は、インメモリ操作に比べて低速です。

**提案:**
- **ストレージインターフェースの抽象化:** `localStorage` のAPIを模倣したインメモリのモックストレージをDI（依存性注入）できるようにします。`WorkoutRepository` はコンストラクタでストレージオブジェクトを受け取るように変更し、テスト時にはこのモックストレージを注入します。これにより、テストの独立性と実行速度が向上します。

## 4. パフォーマンステストの不安定性

**現状:**
`DateFormatter.test.js` や `IdGenerator.test.js` に、`performance.now()` を用いたパフォーマンステストが含まれています。

**課題:**
- **結果の不安定性 (Flakiness):** テストの実行時間は、テストを実行するマシンのスペックやその時の負荷状況に大きく依存します。CI環境など、リソースが共有されている環境では、処理が遅延してテストが失敗する可能性があります。
- **閾値の妥当性:** 「100ms以内」や「1000ms以内」といった閾値に明確な根拠を持たせることは困難です。

**提案:**
- **パフォーマンステストの分離:** ユニットテスト/統合テストのスイートから、このようなマイクロベンチマークは削除します。パフォーマンステストは、`bench` のような専用のフレームワークを使用し、独立したプロセスとして定期的に実行するのが望ましいです。ユニットテストの責務は、あくまで「機能の正当性」を検証することに絞るべきです。

## 5. テストデータ生成の重複

**現状:**
複数のテストファイルで、`new WorkoutEntry(...)` のような形でテストデータが個別に生成されています。

**課題:**
- **コードの重複:** 類似のテストデータ生成コードが複数の場所に散在しています。
- **保守性の低下:** `WorkoutEntry` のコンストラクタ仕様が変更された場合（例えば、プロパティの追加など）、関連する全てのテストファイルを修正する必要があります。

**提案:**
- **テストデータファクトリの導入:** テストデータ生成を責務とするファクトリ関数やクラス（例: `WorkoutEntryFactory` とは別の、テスト専用の `TestWorkoutEntryFactory`）を導入します。このファクトリは、デフォルト値を持つ有効な `WorkoutEntry` インスタンスを生成し、必要に応じてプロパティを上書きできるようにします。
  ```javascript
  // 例:
  function createTestEntry(overrides = {}) {
    const defaults = {
      id: `test-id-${Date.now()}`,
      date: '2025-01-15',
      type: 'ランニング',
      minutes: 30,
      value: 5,
      note: '',
      createdAt: Date.now(),
    };
    return new WorkoutEntry({ ...defaults, ...overrides });
  }
  ```
  これにより、テストコード本体はデータの詳細から解放され、「何をテストしたいのか」という意図がより明確になります。
