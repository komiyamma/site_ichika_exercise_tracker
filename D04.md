# 🗑️ Day 4：記録にIDをつけて、削除ボタンを作ってみよう

*   **今日のテーマ**：Day 3までで作ったメモのテーブルに、「削除」機能を追加します。間違えて入力しちゃった記録も、ちゃんと消せるようにしましょう！
*   **この日のゴール**：記録を作った時間（`createdAt`）をIDとして使って、`onclick="removeButtonClick(...)"`っていう仕組みで、行ごとに削除処理を呼び出せるようになります。

---

## 💡 4.1 `createdAt`は、そのままユニークなIDになる！

Day 3で、`Date.now()`っていう関数を使って`createdAt`（作成日時）を記録しましたよね。この`Date.now()`が返してくれるのは、「その瞬間だけの、とっても大きな数字」です。

同じ瞬間に2回クリック！なんてことがない限り、この数字は他の記録と被ることがありません。だから、それぞれの記録を見分けるための**ユニークなID（背番号）**として、そのまま使えちゃうんです！便利ですよね。

```javascript
// 今この瞬間の時刻をミリ秒単位の数字で取得
const now = Date.now();

// 配列にデータを追加するときに、idプロパティも一緒に入れてあげる
tableEntries.push({
  id: now, // idとしても使う
  text,
  createdAt: now, // 作成日時としても使う
});
```

こうやって配列に保存するときに`id`プロパティを追加しておけば、後で「この記録を消したい！」って思ったときに、正確に目的の記録を見つけ出すことができます。

---

## 🧱 4.2 行ごとに削除ボタンを表示しよう

削除ボタンは、記録一行につき一つずつ必要ですよね。なので、テーブルの行を作る（レンダリングする）ときに、`onclick="removeButtonClick(...)"`っていう魔法の言葉をHTMLに埋め込んであげます。

この`(...)`の中に、さっき決めたID（`createdAt`の数字）を入れてあげることで、「このボタンは、このIDの記録を消すためのボタンだよ」って関連付けることができます。

```javascript
// HTMLの文字列を組み立てるときに、削除ボタンも一緒に追加！
tableHtml += `
  <tr>
    <td>${entry.text}</td>
    <td>その他の項目</td>
    <td>
      <button type="button" class="delete-button" onclick="removeButtonClick('${entry.id}')">削除</button>
    </td>
  </tr>
`;
```

ブラウザの開発者ツールでボタンの部分を見てみると、`onclick="removeButtonClick('168...')"`みたいに、ちゃんとIDが埋め込まれているのが確認できますよ。

---

## 🛠️ 4.3 `removeButtonClick`関数を作ろう！

`removeButtonClick`関数は、ボタンがクリックされたときに呼び出されて、引数としてIDを受け取ります。そのIDを使って、配列（`tableEntries`）の中から「このIDじゃない記録だけを残す」っていう処理をします。

JavaScriptの`filter`メソッドを使うと、この処理がとっても読みやすく、安全に書けますよ。

```javascript
// 削除ボタンが押されたときに呼ばれる関数
function removeButtonClick(targetId) {
  // onclickから渡ってくるIDは文字列なので、Number()で数値に戻してあげる
  const numericId = Number(targetId);
  
  // tableEntries配列の中から、クリックされたIDと一致しないものだけを集めて、新しい配列を作る
  tableEntries = tableEntries.filter((entry) => entry.id !== numericId);
  
  // 配列の中身が変わったので、テーブルの表示をもう一度更新する
  renderTableMemo();
}
```

最後に`renderTableMemo()`を呼び出して画面を再描画すれば、削除した行がちゃんと消えた状態になります。`let tableEntries = []`のように`let`で変数を宣言しておけば、配列そのものを新しいものに差し替えても大丈夫です。

> 💡 **ワンポイント**：`onclick`でHTMLに埋め込んだ値は、JavaScriptに渡されるときには文字列になっています。IDはもともと数値だったので、`Number(...)`で数値に変換してから比較してあげると、`===`（厳密な比較）を使っても、ちゃんと正しく判定できますよ。

---

## 🖼️ 4.4 完成したサンプルコード

削除ボタンの実装を含んだ、最小構成のサンプルコードです。ここまでの手順を一つにまとめたものなので、全体の流れを確認してみてくださいね。

```html
<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>Day 4：削除ボタンの実装</title>
    <style>
      /* （見た目を整えるCSS、内容は前と同じなので省略） */
    </style>
  </head>
  <body>
    <h1>Day 4：削除ボタンの実装</h1>

    <form id="table-memo-form">
      <label for="table-memo" class="required">内容</label>
      <input
        id="table-memo"
        type="text"
        required
        placeholder="例: プランク 40 秒"
      >
      <button type="submit">追加</button>
    </form>

    <table>
      <thead>
        <tr>
          <th>記録内容</th>
          <th>記録したタイミング</th>
          <th>操作</th>
        </tr>
      </thead>
      <tbody id="table-memo-body"></tbody>
    </table>

    <script>
      document.addEventListener('DOMContentLoaded', setupTableMemo);

      let tableEntries = [];

      function setupTableMemo() {
        const tableForm = document.getElementById('table-memo-form');
        tableForm.addEventListener('submit', handleTableMemoSubmit);
        renderTableMemo();
      }

      function handleTableMemoSubmit(event) {
        event.preventDefault();

        const memoInput = document.getElementById('table-memo');
        const text = memoInput.value.trim();
        if (text === '') {
          return;
        }

        const now = Date.now();
        tableEntries.push({
          id: now,
          text,
          createdAt: now,
        });
        renderTableMemo();

        memoInput.value = '';
        memoInput.focus();
      }

      // 削除ボタンが押されたら、この関数が呼ばれる！
      function removeButtonClick(targetId) {
        const numericId = Number(targetId);
        // クリックされたIDと違うものだけを残した、新しい配列を作る
        tableEntries = tableEntries.filter((entry) => entry.id !== numericId);
        // 画面を再描画
        renderTableMemo();
      }

      function renderTableMemo() {
        const tableMemoBody = document.getElementById('table-memo-body');
        const sortedEntries = tableEntries.toSorted(
          (a, b) => b.createdAt - a.createdAt,
        );

        let tableHtml = '';
        for (const entry of sortedEntries) {
          tableHtml += `
            <tr>
              <td>${entry.text}</td>
              <td>${new Date(entry.createdAt).toLocaleString()}</td>
              <td>
                <button type="button" class="delete-button" onclick="removeButtonClick('${entry.id}')">削除</button>
              </td>
            </tr>
          `;
        }

        tableMemoBody.innerHTML = tableHtml;
      }
    </script>
  </body>
</html>
```

---

## ✅ 4.5 ここで押さえておきたいポイント

1.  `Date.now()`で取得した時刻は、IDとして再利用できる便利なもの！
2.  削除ボタンには`onclick`属性を使って、どの記録を消すかのIDを渡してあげる。
3.  `filter`メソッドで新しい配列を作り直して、`renderTableMemo()`を呼び出せば、画面もすぐに更新される。

ここまでで、「追加した行を、ピンポイントで削除できる」仕組みが完成しました！
次のDay 5では、この仕組みをベースに、アプリ全体の設計を考えていきましょう！