# 🗑️ 第4章：`createdAt` を ID にして削除ボタンを検証しよう

* **内容** ：第3章で完成させた「フォーム → 保存 → 表示」の最小テーブルを土台に、行を削除できるかどうかを実験します。`createdAt` が常に増え続ける数値であることに気づき、これを ID として活用する流れを追体験します。
* **目的** ：自前データにユニークな ID を与え、削除ボタンから配列と画面を同期して更新できるようにする。

---

## 🔁 4.1 第3章の振り返りと今回の課題

前回は「フォームでメモを追加 → `createdAt` を付けて最新順に並べる」ところまで進みました。入力した内容はすべて `tableEntries` 配列に入っており、表示するときは `toSorted((a, b) => b.createdAt - a.createdAt)` で新しいものを上に並べています。

そこで次の疑問が浮かびます。

> 「追加はできるけど、間違った行を削除できないままで大丈夫？」

削除を実装するには「どの行を消したいのか」を一意に示す ID が必要です。`createdAt` は `Date.now()`（ミリ秒単位のタイムスタンプ）を保持しているので、**同じタイミングで 2 回クリックしない限り重複しない値** として使えます。ここから「`createdAt` を ID にすればいいかも！」という発見につながります。

---

## 💡 4.2 `createdAt` を ID にできる理由

1. `Date.now()` は 1970 年 1 月 1 日 00:00:00 UTC からの経過ミリ秒を返す数値です。
2. ミリ秒は時間が進むほど大きくなるので、遅く追加したデータほど大きな値を持ちます。
3. 同じミリ秒に 2 回 `Date.now()` を呼ぶケースはほとんどなく、実質的にユニーク ID として扱えます（もし厳密な ID が必要になったら `crypto.randomUUID()` などへ差し替える余地もあります）。

この性質を使えば、削除したい行の `createdAt`（= ID）をボタンに持たせておいて、クリック時にその値で配列をフィルタリングすれば OK です。

---

## 🧪 4.3 実装の流れ（小さなステップで進める）

### Step 0：まずは第3章のコードを動かす
第3章の最終サンプル（`tableEntries.push(text)` で配列に文字列を入れている状態）をそのまま動かし、「追加→最新順で並ぶ」ところまで確認します。削除機能はまだありません。

### Step 1：`createdAt` を使って ID を持たせる
削除するには行を一意に特定する必要があります。配列に文字列だけを入れていた部分を、次のようなオブジェクトに差し替えます。

```javascript
const now = Date.now();
tableEntries.push({
  id: now,
  text,
  createdAt: now,
});
```

コードを保存して再読み込みすると、表示内容は変わらずに動作するはずです（テーブル表示の `entry.text` などが正しく参照できているか確認しましょう）。
このタイミングで、グローバルの配列宣言も `const tableEntries = [];` から `let tableEntries = [];` に替えておくと、後のステップで再代入がしやすくなります。

### Step 2：テーブルに「操作」列を仮追加する
次に、削除ボタン用の列を作ります。まずはボタンを置くだけで OK です。

```html
<th>操作</th>
```

```javascript
tableHtml += `
  <tr>
    <td>${entry.text}</td>
    <td>${recordedAt}</td>
    <td>
      <button type="button" class="delete-button" data-id="${entry.id}">
        削除
      </button>
    </td>
  </tr>
`;
```

この時点ではボタンを押しても何も起こりませんが、行ごとに `data-id` 属性が設定されていることをブラウザの DevTools で確認してみましょう。

### Step 3：ボタンから ID を読み取れるか試す
`tbody` にイベントリスナーを 1 つ追加し、クリックしたボタンの `data-id` を `console.log` で出力してみます。

```javascript
const tableMemoBody = document.getElementById('table-memo-body');
tableMemoBody.addEventListener('click', handleDeleteButtonClick);

function handleDeleteButtonClick(event) {
  if (!event.target.matches('.delete-button')) {
    return;
  }

  const targetId = Number(event.target.dataset.id);
  console.log('削除してみたい ID:', targetId);
}
```

ページを更新してボタンを押すと、コンソールに ID（= `createdAt`）が表示されるようになります。ここまでくれば「どの行を消したいのか」が分かる状態です。

> ❓ なぜ `tbody` に 1 回だけイベントリスナーをつけるの？
>
> * 行を追加するたびにボタンは増えますが、`tbody` は変わらない 1 つの要素です。親にリスナーを置けば、新しく増えたボタンも自動で反応します。
> * ボタンごとに `addEventListener` する手間がなくなり、コードもブラウザの仕事量も少なくて済みます。こうして親要素が代表して受け止める書き方だと覚えておけば十分です（専門用語ではイベントデリゲーションと呼ばれます）。

> 🔍 ワンポイント：`dataset` 経由で取り出した値は文字列として渡されます。そのままでは配列に入っている数値の ID（`createdAt`）と型が違うため、`===` で比較しても一致しません。`Number(...)` で数値に変換しておけば、後続の `filter` で期待通りにマッチしてくれます。「文字列か数値か」を意識すると、JavaScript の比較ルールに早く慣れられます。


### Step 4：配列から該当データを取り除く

実際に削除処理を入れます。`filter` で ID が一致しないものだけ残し、元の配列を置き換えます。置き換え後はいつも通り `renderTableMemo()` を呼んで再描画します。

```javascript
tableEntries = tableEntries.filter((entry) => entry.id !== targetId);
renderTableMemo();
```

これで削除ボタンを押すたびに行が消えるようになりました。`let tableEntries = []` としておけば、配列をまるごと差し替えるだけで済みます。

### Step 5：最新順の並びを保つ

削除後も最新順で見られるよう、`renderTableMemo` 内ではこれまで通り `toSorted((a, b) => b.createdAt - a.createdAt)` を使います。並び替えが入っていても、削除時に `createdAt` を ID として扱っているので問題ありません。

これらのステップを順番に積み上げると、次節の完成版コードに到達します。途中でエラーが出たら、どの段階の変更かに戻って一つずつ確認してみてください。

---

## 🧾 4.4 完成した検証コード

第3章の最終サンプルから、削除列を追加した完全版です。ブラウザでそのまま動かせば「追加 → 表示 → 削除」の一連の動きが確認できます。

```html
<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>第4章：削除ボタンの検証</title>
    <style>
      body {
        font-family: sans-serif;
        margin: 24px;
        max-width: 720px;
      }

      form,
      table {
        margin-bottom: 24px;
      }

      table {
        border-collapse: collapse;
        width: 100%;
      }

      th,
      td {
        border: 1px solid #888;
        padding: 8px;
        text-align: left;
      }

      .required::after {
        content: " *";
        color: #c00;
      }
    </style>
  </head>
  <body>
    <h1>第4章：削除ボタンの検証</h1>

    <form id="table-memo-form">
      <label for="table-memo" class="required">メモ</label>
      <input id="table-memo" type="text" required placeholder="例: プランク 40 秒">
      <button type="submit">追加</button>
    </form>

    <table>
      <thead>
        <tr>
          <th>メモ内容</th>
          <th>その他の項目</th>
          <th>操作</th>
        </tr>
      </thead>
      <tbody id="table-memo-body"></tbody>
    </table>

    <script>
      document.addEventListener('DOMContentLoaded', setupTableMemo);

      let tableEntries = [];

      function setupTableMemo() {
        const tableForm = document.getElementById('table-memo-form');
        const tableMemoBody = document.getElementById('table-memo-body');

        tableForm.addEventListener('submit', handleTableMemoSubmit);
        tableMemoBody.addEventListener('click', handleDeleteButtonClick);

        renderTableMemo();
      }

      function handleTableMemoSubmit(event) {
        event.preventDefault();

        const memoInput = document.getElementById('table-memo');
        const text = memoInput.value.trim();
        if (text === '') {
          return;
        }

        const now = Date.now();
        tableEntries.push({
          id: now,
          text,
          createdAt: now,
        });
        renderTableMemo();

        memoInput.value = '';
        memoInput.focus();
      }

      function handleDeleteButtonClick(event) {
        if (!event.target.matches('.delete-button')) {
          return;
        }

        const targetId = Number(event.target.dataset.id);
        tableEntries = tableEntries.filter((entry) => entry.id !== targetId);

        renderTableMemo();
      }

      function renderTableMemo() {
        const tableMemoBody = document.getElementById('table-memo-body');

        const sortedEntries = tableEntries.toSorted((a, b) => b.createdAt - a.createdAt);

        let tableHtml = '';
        for (const entry of sortedEntries) {
          tableHtml += `
            <tr>
              <td>${entry.text}</td>
              <td>その他の項目などなど</td>
              <td>
                <button type="button" class="delete-button" data-id="${entry.id}">
                  削除
                </button>
              </td>
            </tr>
          `;
        }

        tableMemoBody.innerHTML = tableHtml;
      }
    </script>
  </body>
</html>
```


## 🧠 4.5 先を見据えた観察ポイント

* 削除ボタンを実現するためには「一意な ID」と「配列から取り除く処理」が必要だと分かりました。第5章で要件定義を書くときに「ID が必要」という気づきを反映できます。
* クリックイベントは `tbody` に 1 回登録しておき、実際に押されたボタンは `event.target` で判定する形がシンプルでした。新しく足したボタンも自動で拾えて、ボタンごとに処理を書き足す必要がありません。こうした「親がまとめて受け取る」書き方は、のちにイベントデリゲーションと呼ばれる考え方ですが、まずは流れを追えることを大事にしましょう。
* 今回は `createdAt` をそのまま ID として使いましたが、より厳密なユニーク ID が必要になったら `crypto.randomUUID()` や外部ライブラリを利用する道もあります。
* `tableEntries` から配列全体を作り直し、再描画するのは `script.js` 本編と同じ考え方です。ここでは削除の有無を確認するため、全件再描画でも十分高速に動作します。

---

## ✅ 4.6 まとめ

1. `createdAt`（`Date.now()` の戻り値）が実質的にユニーク ID として使えると気づいた。
2. 削除ボタンには `data-id` で ID を紐づけ、クリック時に配列をフィルタリングして再描画する流れを作った。
3. イベントデリゲーションや配列の差し替えなど、`script.js` 本編でも活きる基礎パターンを体験できた。

これで第4章の実験は成功です。次の第5章では、これまでの気づきを要件定義に落とし込み、アプリ全体の仕様を固めていきましょう！
