# 🗑️ 第4章：`createdAt` を ID にして `removeButtonClick` で削除を実装しよう

* **目的**：第3章までで作ったメモテーブルに「削除」機能を追加し、余計なデータを残さないようにする。
* **到達点**：`createdAt` を ID として使い、`onclick="removeButtonClick(...)"` で行ごとに削除処理を呼び出せるようにする。

---

## 💡 4.1 `createdAt` はそのままユニーク ID になる

第3章で `Date.now()` を `createdAt` として保存していたのは、時間とともに必ず大きくなる「その瞬間だけの数字」です。同じ瞬間に 2 回クリックしない限り重複しないので、ID としてそのまま流用できます。

```javascript
const now = Date.now();
tableEntries.push({
  id: now,
  text,
  createdAt: now,
});
```

配列に保存するときに `id` プロパティを追加しておけば、後で削除したい要素を特定できます。

---

## 🧱 4.2 行ごとに削除ボタンを描画する

削除ボタンは各行に 1 つずつ必要なので、レンダリング時に `onclick="removeButtonClick(...)"` を埋め込みます。ここで数値の ID（`createdAt`）を文字列として渡しておくと、クリックした行に対応した ID をそのまま受け取れます。

```javascript
tableHtml += `
  <tr>
    <td>${entry.text}</td>
    <td>その他の項目</td>
    <td>
      <button type="button" class="delete-button" onclick="removeButtonClick('${entry.id}')">削除</button>
    </td>
  </tr>
`;
```

DevTools でボタンを選択すると、`onclick="removeButtonClick('168...')"` のように ID が埋め込まれていることが確認できます。

---

## 🛠️ 4.3 `removeButtonClick` を実装する

`removeButtonClick` はクリックされたボタンから受け取った ID を使って、対象の要素だけを配列から取り除きます。`filter` を使うと読みやすく、安全に配列を再構築できます。

```javascript
function removeButtonClick(targetId) {
  const numericId = Number(targetId);
  tableEntries = tableEntries.filter((entry) => entry.id !== numericId);
  renderTableMemo();
}
```

`renderTableMemo()` を呼び出して再描画すれば、削除後の行だけが表示されます。`let tableEntries = []` としておけば、配列そのものを差し替えても問題ありません。

> 💡 ワンポイント：`onclick` から渡ってくる値は文字列です。`Number(...)` で数値に変換してから比較すると、`===` でも意図どおりに判定できます。

---

## 🖼️ 4.4 完成したサンプルコード

削除ボタンを含む最小構成のサンプルです。ここまでの手順を順番に反映したものになっています。

```html
<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>第4章：削除ボタンの実装</title>
    <style>
      body {
        font-family: sans-serif;
        margin: 24px;
        max-width: 720px;
      }

      form,
      table {
        margin-bottom: 24px;
      }

      table {
        border-collapse: collapse;
        width: 100%;
      }

      th,
      td {
        border: 1px solid #888;
        padding: 8px;
        text-align: left;
      }

      .required::after {
        content: " *";
        color: #c00;
      }
    </style>
  </head>
  <body>
    <h1>第4章：削除ボタンの実装</h1>

    <form id="table-memo-form">
      <label for="table-memo" class="required">内容</label>
      <input
        id="table-memo"
        type="text"
        required
        placeholder="例: プランク 40 秒"
      >
      <button type="submit">追加</button>
    </form>

    <table>
      <thead>
        <tr>
          <th>記録内容</th>
          <th>記録したタイミング</th>
          <th>操作</th>
        </tr>
      </thead>
      <tbody id="table-memo-body"></tbody>
    </table>

    <script>
      document.addEventListener('DOMContentLoaded', setupTableMemo);

      let tableEntries = [];

      function setupTableMemo() {
        const tableForm = document.getElementById('table-memo-form');

        tableForm.addEventListener('submit', handleTableMemoSubmit);
        renderTableMemo();
      }

      function handleTableMemoSubmit(event) {
        event.preventDefault();

        const memoInput = document.getElementById('table-memo');
        const text = memoInput.value.trim();
        if (text === '') {
          return;
        }

        const now = Date.now();
        tableEntries.push({
          id: now,
          text,
          createdAt: now,
        });
        renderTableMemo();

        memoInput.value = '';
        memoInput.focus();
      }

      function removeButtonClick(targetId) {
        const numericId = Number(targetId);
        tableEntries = tableEntries.filter((entry) => entry.id !== numericId);
        renderTableMemo();
      }

      function renderTableMemo() {
        const tableMemoBody = document.getElementById('table-memo-body');
        const sortedEntries = tableEntries.toSorted(
          (a, b) => b.createdAt - a.createdAt,
        );

        let tableHtml = '';
        for (const entry of sortedEntries) {
          tableHtml += `
            <tr>
              <td>${entry.text}</td>
              <td>その他の項目</td>
              <td>
                <button type="button" class="delete-button" onclick="removeButtonClick('${entry.id}')">削除
              </td>
            </tr>
          `;
        }

        tableMemoBody.innerHTML = tableHtml;
      }
    </script>
  </body>
</html>
```

---

## ✅ 4.5 ここで押さえておきたいポイント

1. `Date.now()` を `id` に再利用すれば、追加と削除の両方で同じ値を参照できる。
2. 削除ボタンは行ごとに `onclick` で ID を渡し、`removeButtonClick` で配列から取り除く。
3. `filter` で新しい配列を作り、`renderTableMemo()` を呼び直せば画面もすぐに更新できる。

ここまでで「追加した行をピンポイントに削除できる」仕組みが完成しました。次章では、この仕組みをベースにアプリ全体の設計へ進みます。
