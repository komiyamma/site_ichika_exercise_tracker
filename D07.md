

# 📦 第7章：データ構造と `localStorage` の理解 🐾

## 🌟 7.1 思考の軌跡：データをどう保存するか

最初にやるべきことは、 **データをどう保存するか** です。`localStorage`は、ブラウザにデータを保存するための便利な方法で、データを **永続的に保存** することができます。今回は、運動記録を **`localStorage`に保存** して、ページがリロードされてもデータを消さないようにします。

---

## 🌼 7.2 `localStorage`の基本を理解する

まずは、 **`localStorage`の基本的な使い方** を学びます。`localStorage`は、ブラウザに **キーと値のペア** としてデータを保存します。保存したデータはページをリロードしても残り、次回アクセスしたときにも利用できます。

### **基本的な使い方**

```javascript
// データを保存する
localStorage.setItem('key', 'value');

// データを取得する
const value = localStorage.getItem('key');

// データを削除する
localStorage.removeItem('key');
```

### **思考の軌跡** ：

「`localStorage`にデータを保存するには、 **文字列に変換して保存** する必要がある。だから、 **オブジェクトを文字列に変換** し、後で取り出すときは **文字列をオブジェクトに戻す** 必要がある。」

---

## 🌸 7.3 データ構造を設計する

運動記録を保存するための **データ構造** を考えます。運動記録には、運動種目、日付、時間、回数、メモなどが含まれるので、これらの情報をひとまとめにして保存する必要があります。

### **思考の軌跡** ：

「運動記録を保存するためには、少なくとも **運動種目、日付、時間、回数、メモ** が必要だ。これらの情報をひとつのオブジェクトにまとめて、`localStorage`に保存しよう。」

#### **データ構造の例** ：

```javascript
{
    id: '1678535800000', // Date.now() の結果を文字列化したもの（削除や編集時に使用）
    date: '2023-04-01',
    type: 'ランニング',
    minutes: 30,
    value: 5,
    note: '今日は調子が良かった',
    createdAt: 1678535800000 // 上と同じタイムスタンプを数値で保持しておく
}
```

### **思考の軌跡** ：

「この構造を使ってデータを保存し、後で取得して表示できるようにしよう。」

---

## 🔢 7.4 一意なIDの決め方を考える

データ構造が定まったら、次は **各記録をどう識別するか** を考えます。削除や編集をするときに「どの記録を操作するのか」を一意に判別できるようにしておく必要があります。

### **思考の軌跡** ：

- 「配列のインデックスをそのまま使うと、並び替えた瞬間にズレてしまう。」
- 「ランダム文字列を作る選択肢もあるが、初心者が仕組みを追いづらい。」
- 「時間の流れは常に前に進むから、作成時刻をそのままIDにすればほぼ重複しないはず。」

#### **候補を比較してみる**

| 方式                  | 良いところ                             | 気になるところ                         |
|-----------------------|----------------------------------------|----------------------------------------|
| 配列のインデックス    | すぐ使える                             | 並び替えや削除で値が変わってしまう     |
| ランダム文字列        | 重複しにくい                           | アルゴリズムの理解が必要               |
| `Date.now()` の結果   | 仕組みが直感的で再現しやすい           | 数字が長いので扱うときは注意が必要     |

`Date.now()` は **「現在時刻をミリ秒で返す関数」** です。同じ瞬間に2回呼び出さない限り重複せず、時間の情報としても使い回せます。そこで、ID生成専用の関数 `generateEntryId()` を作り、いつでも同じ手順でIDを作れるようにしておきます。

```javascript
// 記録ごとに一意なID（=作成時刻のミリ秒）を返す
function generateEntryId() {
    return Date.now();
}
```

> 後で `createdAt` としても同じ値を使いたいので、**IDは数値のまま受け取り、必要に応じて文字列に変換** する方針にしておきます。

---

## 🌼 7.5 フォームから値を取り出す準備

フォームに入力された値を確実に取得するため、まずは各入力欄への参照をまとめます。  
まとめた後は Console から実際に値を読み取り、狙ったデータが取得できているか確認しましょう。

### **思考の軌跡** ：

- 「`document.getElementById` を毎回書くより、一度まとめた方が読みやすい」
- 「変数に格納できたかは Console で確認しておくと不安が減る」

#### **ステップ1: 参照をまとめる**

```javascript
let entryFormElement;
let dateInputElement;
let typeInputElement;
let minutesInputElement;
let valueInputElement;
let noteInputElement;

function assignElementReferences() {
    entryFormElement = document.getElementById('entry-form');
    dateInputElement = document.getElementById('date');
    typeInputElement = document.getElementById('type');
    minutesInputElement = document.getElementById('minutes');
    valueInputElement = document.getElementById('value');
    noteInputElement = document.getElementById('note');
}
```

**Consoleチェック**  
`assignElementReferences()` を実行し、`typeInputElement` などを表示して想定した要素が入っているか確かめる。フォームに値を入れた後、`typeInputElement.value` の結果も確認する。

#### **ステップ2: フォーム値をオブジェクトへ**

```javascript
function getFormData() {
    const timestamp = generateEntryId();

    return {
        id: String(timestamp),
        date: dateInputElement.value,
        type: typeInputElement.value,
        minutes: parseInt(minutesInputElement.value, 10) || 0,
        value: parseInt(valueInputElement.value, 10) || 0,
        note: noteInputElement.value.trim(),
        createdAt: timestamp
    };
}
```

**Consoleチェック**  
フォームに値を入力後、`getFormData()` を実行してオブジェクトの中身を確認。数値欄を空にした場合など、さまざまなケースで挙動を確かめておくと安心です。

---

## 🪄 7.6 `localStorage` とやり取りする土台

配列全体を読み出し・書き戻しする関数を用意し、Consoleからもテストしておきます。

```javascript
const WORKOUT_STORAGE_KEY = 'ichikaWorkoutLogEntries';

function loadEntriesFromStorage() {
    const rawData = localStorage.getItem(WORKOUT_STORAGE_KEY);
    return rawData ? JSON.parse(rawData) : [];
}

function saveEntriesToStorage(entries) {
    localStorage.setItem(WORKOUT_STORAGE_KEY, JSON.stringify(entries));
}
```

**Consoleチェック**  
`loadEntriesFromStorage()` → 期待どおりの配列が返るか。  
`saveEntriesToStorage([{ id: 'draft', createdAt: Date.now() }])` と呼び、再度 `loadEntriesFromStorage()` で確認。不要になったら `localStorage.removeItem(WORKOUT_STORAGE_KEY)` で片付ける。

---

## 🌸 7.7 フォーム送信イベントを結び付ける

HTMLに直接 `onsubmit` を書く代わりに、JavaScriptからイベントを登録して処理の流れを集中管理します。

```javascript
function attachEventListeners() {
    entryFormElement.addEventListener('submit', handleFormSubmit);
}

function handleFormSubmit(event) {
    event.preventDefault();

    const entry = getFormData();
    const entries = loadEntriesFromStorage();
    entries.push(entry);
    saveEntriesToStorage(entries);

    entryFormElement.reset();
    console.log('[handleFormSubmit] 保存件数:', entries.length);
}
```

**Consoleチェック**  
フォーム送信後に `console.log` の件数が増えていくか、`loadEntriesFromStorage()` の結果が併せて変わっているかを確認。

---

## 🧪 7.8 ここまでの流れを手動で通してみる

1. ブラウザを開き、Console で `initializePage()` を呼ぶかページをリロードして初期化。
2. フォームへ値を入力 → 送信。
3. `loadEntriesFromStorage()` で配列に新しい要素が追加されたか確認。
4. 必要に応じて `localStorage.removeItem(WORKOUT_STORAGE_KEY)` でリセットして再挑戦。

---

## 🧩 7.9 ここまでのコードをまとめて確認する

バラバラに作った関数を一つのファイルに並べると、保存の流れがはっきり見えてきます。  
ここまでで組み立てたパーツを順番に貼り合わせ、フォーム入力から `localStorage` 保存までが一本の線でつながることを確かめましょう。

```javascript
const WORKOUT_STORAGE_KEY = 'ichikaWorkoutLogEntries';

let entryFormElement;
let dateInputElement;
let typeInputElement;
let minutesInputElement;
let valueInputElement;
let noteInputElement;

function assignElementReferences() {
    entryFormElement = document.getElementById('entry-form');
    dateInputElement = document.getElementById('date');
    typeInputElement = document.getElementById('type');
    minutesInputElement = document.getElementById('minutes');
    valueInputElement = document.getElementById('value');
    noteInputElement = document.getElementById('note');
}

function attachEventListeners() {
    entryFormElement.addEventListener('submit', handleFormSubmit);
}

function generateEntryId() {
    return Date.now();
}

function getFormData() {
    const timestamp = generateEntryId();

    return {
        id: String(timestamp),
        date: dateInputElement.value,
        type: typeInputElement.value,
        minutes: parseInt(minutesInputElement.value, 10) || 0,
        value: parseInt(valueInputElement.value, 10) || 0,
        note: noteInputElement.value.trim(),
        createdAt: timestamp
    };
}

function loadEntriesFromStorage() {
    const rawData = localStorage.getItem(WORKOUT_STORAGE_KEY);
    return rawData ? JSON.parse(rawData) : [];
}

function saveEntriesToStorage(entries) {
    localStorage.setItem(WORKOUT_STORAGE_KEY, JSON.stringify(entries));
}

function handleFormSubmit(event) {
    event.preventDefault();

    const entry = getFormData();
    const entries = loadEntriesFromStorage();
    entries.push(entry);
    saveEntriesToStorage(entries);

    entryFormElement.reset();
}

function initializePage() {
    assignElementReferences();
    attachEventListeners();
    // ここでは保存処理のみ。表示更新は第8章で追加します。
}

document.addEventListener('DOMContentLoaded', initializePage);
```

---

### **コードの詳細説明** ：

1. **`assignElementReferences` / `attachEventListeners`** ：フォーム要素を一元管理し、送信イベントを `handleFormSubmit` に結びつける初期化処理です。

2. **`getFormData`** ：フォームからデータを取得する関数です。フォームの各入力フィールド（運動種目、日付、時間、回数、メモ）から値を取り出し、1つのオブジェクトにまとめて返します。

3. **`generateEntryId`** ：エントリーデータに一意のIDを付与する関数です。`Date.now()`で現在の時間（ミリ秒）を返し、`getFormData` 側で文字列化してIDに使いながら、同じ値を `createdAt` としても保持します。

4. **`loadEntriesFromStorage` / `saveEntriesToStorage`** ：`localStorage` とのやり取りを担当します。保存内容を配列として読み込み、更新後の配列を丸ごと書き戻します。

5. **`handleFormSubmit`** ：フォームが送信されたときに `getFormData` を呼び、配列へ追加して保存し直します。その後 `entryFormElement.reset()` で入力欄を初期化します（実装版ではここで日付を今日に戻す処理も加わります）。

---

### **これまでのステップにおける実装の流れ** ：

* 第7章では、まずデータの保存方法を学び、 **`localStorage`にデータを保存** する方法を実装しました。
* 次に、フォームから入力されたデータを **`localStorage`に保存** し、その後 **データを表示する準備** を進めました。

このコードを使えば、運動記録をフォームで入力し、ブラウザをリロードしてもデータが **`localStorage`に保存** されるため、 **永続的にデータを保持** できます。

次回は、この保存されたデータを **テーブルに表示する** 処理を追加していきます。

---

## 🌼 7.10 次のステップに進む準備

ここまでで、 **`localStorage`にデータを保存する仕組み** が完成しました。次回は、保存されたデータを **テーブルに表示** し、ユーザーが運動記録を後で確認できるようにします。

### **まとめ** ：

* **`localStorage`を使ってデータを保存する方法** を理解しました。
* フォームから取得したデータを **`localStorage`に保存** し、その後 **表示する準備** をしました。
* 次回は、 **保存されたデータを画面に表示** する処理に進みます。

---

## 🌼 **やさしい補足：実際の `script.js` では…？**

ここまでのコードは「流れを理解するための最短ルート」です。最終版の `script.js` では、勉強が進んだときに取り入れたい少しだけ大人な書き方が加わっています。

* `loadEntriesFromStorage` では try / catch を入れて、読み込み失敗時にもアプリが止まらないようにしています。
* `handleFormSubmit` の最後で今日の日付を再セットし、`renderEntryTable()` を呼んで画面も同時に更新しています（第8章で詳しく扱います）。
* 後続の章で扱うフィルターや削除ボタンも、ここで紹介した変数や関数に追記していくだけで連携できる構造になっています。

まずはこの章のシンプルなコードで「仕組み」を理解し、慣れてきたら実際のソースと見比べながら、こうした工夫を少しずつ真似していきましょうね。

> 📝 `JSON.stringify` や `JSON.parse` を忘れてしまうと、localStorage に保存したデータがそのまま文字列になってしまいます。「ちゃんと配列に戻っているかな？」と心配になったら、`console.log` で途中経過をのぞいてみると安心です。
