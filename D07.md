

# 📦 第7章：データ構造と `localStorage` の理解 🐾

## 🌟 7.1 思考の軌跡：データをどう保存するか

最初にやるべきことは、 **データをどう保存するか** です。`localStorage`は、ブラウザにデータを保存するための便利な方法で、データを **永続的に保存** することができます。今回は、運動記録を **`localStorage`に保存** して、ページがリロードされてもデータを消さないようにします。

---

## 🌼 7.2 `localStorage`の基本を理解する

まずは、 **`localStorage`の基本的な使い方** を学びます。`localStorage`は、ブラウザに **キーと値のペア** としてデータを保存します。保存したデータはページをリロードしても残り、次回アクセスしたときにも利用できます。

### **基本的な使い方**

```javascript
// データを保存する
localStorage.setItem('key', 'value');

// データを取得する
const value = localStorage.getItem('key');

// データを削除する
localStorage.removeItem('key');
```

### **思考の軌跡** ：

「`localStorage`にデータを保存するには、 **文字列に変換して保存** する必要がある。だから、 **オブジェクトを文字列に変換** し、後で取り出すときは **文字列をオブジェクトに戻す** 必要がある。」

---

## 🌸 7.3 データ構造を設計する

運動記録を保存するための **データ構造** を考えます。運動記録には、運動種目、日付、時間、回数、メモなどが含まれるので、これらの情報をひとまとめにして保存する必要があります。

### **思考の軌跡** ：

「運動記録を保存するためには、少なくとも **運動種目、日付、時間、回数、メモ** が必要だ。これらの情報をひとつのオブジェクトにまとめて、`localStorage`に保存しよう。」

#### **データ構造の例** ：

```javascript
{
    id: '1678535800000', // Date.now() の結果を文字列化したもの（削除や編集時に使用）
    date: '2023-04-01',
    type: 'ランニング',
    minutes: 30,
    value: 5,
    note: '今日は調子が良かった',
    createdAt: 1678535800000 // 上と同じタイムスタンプを数値で保持しておく
}
```

### **思考の軌跡** ：

「この構造を使ってデータを保存し、後で取得して表示できるようにしよう。」

---

## 🔢 7.4 一意なIDの決め方を考える

データ構造が定まったら、次は **各記録をどう識別するか** を考えます。削除や編集をするときに「どの記録を操作するのか」を一意に判別できるようにしておく必要があります。

### **思考の軌跡** ：

- 「配列のインデックスをそのまま使うと、並び替えた瞬間にズレてしまう。」
- 「ランダム文字列を作る選択肢もあるが、初心者が仕組みを追いづらい。」
- 「時間の流れは常に前に進むから、作成時刻をそのままIDにすればほぼ重複しないはず。」

#### **候補を比較してみる**

| 方式                  | 良いところ                             | 気になるところ                         |
|-----------------------|----------------------------------------|----------------------------------------|
| 配列のインデックス    | すぐ使える                             | 並び替えや削除で値が変わってしまう     |
| ランダム文字列        | 重複しにくい                           | アルゴリズムの理解が必要               |
| `Date.now()` の結果   | 仕組みが直感的で再現しやすい           | 数字が長いので扱うときは注意が必要     |

`Date.now()` は **「現在時刻をミリ秒で返す関数」** です。同じ瞬間に2回呼び出さない限り重複せず、時間の情報としても使い回せます。そこで、ID生成専用の関数 `generateEntryId()` を作り、いつでも同じ手順でIDを作れるようにしておきます。

```javascript
// 記録ごとに一意なID（=作成時刻のミリ秒）を返す
function generateEntryId() {
    return Date.now();
}
```

> 後で `createdAt` としても同じ値を使いたいので、**IDは数値のまま受け取り、必要に応じて文字列に変換** する方針にしておきます。

---

## 🌼 7.5 フォームからデータを取得する準備

次に進む前に、フォームからデータをどう取得するかを確認します。 **フォームに入力されたデータ** は、ユーザーが記録した運動情報を反映させるために必要です。最初は、フォームのデータを取得するコードを用意しておきます。

### **思考の軌跡** ：

「フォームからデータを取得するためには、 **DOMを操作** して、それぞれの入力フィールドから値を取得する必要がある。」

#### **フォームデータを取得するコード** ：

```javascript
// フォームからデータを取得する関数
function getFormData() {
    const timestamp = generateEntryId();

    return {
        id: String(timestamp), // 保存時に扱いやすいように文字列化
        date: dateInputElement.value,
        type: typeInputElement.value,
        minutes: parseInt(minutesInputElement.value, 10) || 0,
        value: parseInt(valueInputElement.value, 10) || 0,
        note: noteInputElement.value.trim(),
        createdAt: timestamp
    };
}
```

### **思考の軌跡** ：

「フォームからデータを取得する方法が分かった。次は、これらのデータをどう保存するかを考えよう。」

#### 🧠 思考のメモ
- `generateEntryId()` を先に呼び出してタイムスタンプを確保すると、ID と `createdAt` を同じ値で揃えられる
- ID を文字列に変換しておくと、`localStorage` に保存した後でも比較や検索がしやすい
- 数値のまま残した `createdAt` は、後で並び替えやフィルターに流用できる

---

## 🪄 7.6 よく使う要素への参照をまとめておく

保存や送信処理をスッキリ書くために、フォーム要素をまとめて変数に保持しておきます。  
こうしておけば、どの関数からでも同じ要素を参照でき、`document.getElementById` を毎回呼ぶ必要がなくなります。

```javascript
let entryFormElement;
let dateInputElement;
let typeInputElement;
let minutesInputElement;
let valueInputElement;
let noteInputElement;

function assignElementReferences() {
    entryFormElement = document.getElementById('entry-form');
    dateInputElement = document.getElementById('date');
    typeInputElement = document.getElementById('type');
    minutesInputElement = document.getElementById('minutes');
    valueInputElement = document.getElementById('value');
    noteInputElement = document.getElementById('note');
}

function attachEventListeners() {
    entryFormElement.addEventListener('submit', handleFormSubmit);
}
```

> この形は `script.js` と同じ流れです。ページ読み込み時に `initializePage()` からこの2つを呼び出しておけば、以降の処理で同じ要素をいつでも参照できます。のちの章でテーブルやフィルターを扱う際も、この関数に取得処理を追加するだけで済みます。

---

## 🌸 7.7 `localStorage` に保存する

次に、 **取得したデータを `localStorage` に保存** する方法を実装します。データを保存する際、すでに保存されているデータがあれば、それを **配列として読み込み** 、新しいデータを **追加** してから再び保存します。

### **思考の軌跡** ：

「フォームから取得したデータを **`localStorage`に保存** するために、すでに保存されているデータを **読み込んで** 、新しいデータを追加し、再度保存する。」

#### **`localStorage` に保存するコード** ：

```javascript
const WORKOUT_STORAGE_KEY = 'ichikaWorkoutLogEntries';

function loadEntriesFromStorage() {
    const rawData = localStorage.getItem(WORKOUT_STORAGE_KEY);
    return rawData ? JSON.parse(rawData) : [];
}

function saveEntriesToStorage(entries) {
    localStorage.setItem(WORKOUT_STORAGE_KEY, JSON.stringify(entries));
}
```

### **思考の軌跡** ：

「データを`localStorage`に保存する準備が整った。これで、ユーザーが入力した運動記録を **保存できる** 。」

---

## 🌸 7.8 フォーム送信時にデータを保存する

フォームが送信されるとき、入力されたデータを取得し、それを`localStorage`に保存する処理を追加します。フォームの送信を **非同期で処理** するために、 **`submit`イベント** を使います。

### **思考の軌跡** ：

「フォームが送信されたときに、データを **`localStorage`に保存** するようにしたい。 **送信後はフォームをリセット** し、次の入力ができるようにする。」

#### **フォーム送信時の処理** ：

```javascript
function handleFormSubmit(event) {
    event.preventDefault();

    const entry = getFormData();
    const entries = loadEntriesFromStorage();
    entries.push(entry);
    saveEntriesToStorage(entries);

    entryFormElement.reset();
}
```

### **思考の軌跡** ：

「フォームが送信されると、データが保存されるようになった。これで、ユーザーが入力したデータを **永続的に保存** できるようになった。」

---

## 🧩 7.9 ここまでのコードをまとめて確認する

バラバラに作った関数を一つのファイルに並べると、保存の流れがはっきり見えてきます。  
ここまでで組み立てたパーツを順番に貼り合わせ、フォーム入力から `localStorage` 保存までが一本の線でつながることを確かめましょう。

```javascript
const WORKOUT_STORAGE_KEY = 'ichikaWorkoutLogEntries';

let entryFormElement;
let dateInputElement;
let typeInputElement;
let minutesInputElement;
let valueInputElement;
let noteInputElement;

function assignElementReferences() {
    entryFormElement = document.getElementById('entry-form');
    dateInputElement = document.getElementById('date');
    typeInputElement = document.getElementById('type');
    minutesInputElement = document.getElementById('minutes');
    valueInputElement = document.getElementById('value');
    noteInputElement = document.getElementById('note');
}

function attachEventListeners() {
    entryFormElement.addEventListener('submit', handleFormSubmit);
}

function generateEntryId() {
    return Date.now();
}

function getFormData() {
    const timestamp = generateEntryId();

    return {
        id: String(timestamp),
        date: dateInputElement.value,
        type: typeInputElement.value,
        minutes: parseInt(minutesInputElement.value, 10) || 0,
        value: parseInt(valueInputElement.value, 10) || 0,
        note: noteInputElement.value.trim(),
        createdAt: timestamp
    };
}

function loadEntriesFromStorage() {
    const rawData = localStorage.getItem(WORKOUT_STORAGE_KEY);
    return rawData ? JSON.parse(rawData) : [];
}

function saveEntriesToStorage(entries) {
    localStorage.setItem(WORKOUT_STORAGE_KEY, JSON.stringify(entries));
}

function handleFormSubmit(event) {
    event.preventDefault();

    const entry = getFormData();
    const entries = loadEntriesFromStorage();
    entries.push(entry);
    saveEntriesToStorage(entries);

    entryFormElement.reset();
}

function initializePage() {
    assignElementReferences();
    attachEventListeners();
    // ここでは保存処理のみ。表示更新は第8章で追加します。
}

document.addEventListener('DOMContentLoaded', initializePage);
```

---

### **コードの詳細説明** ：

1. **`assignElementReferences` / `attachEventListeners`** ：フォーム要素を一元管理し、送信イベントを `handleFormSubmit` に結びつける初期化処理です。

2. **`getFormData`** ：フォームからデータを取得する関数です。フォームの各入力フィールド（運動種目、日付、時間、回数、メモ）から値を取り出し、1つのオブジェクトにまとめて返します。

3. **`generateEntryId`** ：エントリーデータに一意のIDを付与する関数です。`Date.now()`で現在の時間（ミリ秒）を返し、`getFormData` 側で文字列化してIDに使いながら、同じ値を `createdAt` としても保持します。

4. **`loadEntriesFromStorage` / `saveEntriesToStorage`** ：`localStorage` とのやり取りを担当します。保存内容を配列として読み込み、更新後の配列を丸ごと書き戻します。

5. **`handleFormSubmit`** ：フォームが送信されたときに `getFormData` を呼び、配列へ追加して保存し直します。その後 `entryFormElement.reset()` で入力欄を初期化します（実装版ではここで日付を今日に戻す処理も加わります）。

---

### **これまでのステップにおける実装の流れ** ：

* 第7章では、まずデータの保存方法を学び、 **`localStorage`にデータを保存** する方法を実装しました。
* 次に、フォームから入力されたデータを **`localStorage`に保存** し、その後 **データを表示する準備** を進めました。

このコードを使えば、運動記録をフォームで入力し、ブラウザをリロードしてもデータが **`localStorage`に保存** されるため、 **永続的にデータを保持** できます。

次回は、この保存されたデータを **テーブルに表示する** 処理を追加していきます。

---

## 🌼 7.10 次のステップに進む準備

ここまでで、 **`localStorage`にデータを保存する仕組み** が完成しました。次回は、保存されたデータを **テーブルに表示** し、ユーザーが運動記録を後で確認できるようにします。

### **まとめ** ：

* **`localStorage`を使ってデータを保存する方法** を理解しました。
* フォームから取得したデータを **`localStorage`に保存** し、その後 **表示する準備** をしました。
* 次回は、 **保存されたデータを画面に表示** する処理に進みます。

---

## 🌼 **やさしい補足：実際の `script.js` では…？**

ここまでのコードは「流れを理解するための最短ルート」です。最終版の `script.js` では、勉強が進んだときに取り入れたい少しだけ大人な書き方が加わっています。

* `loadEntriesFromStorage` では try / catch を入れて、読み込み失敗時にもアプリが止まらないようにしています。
* `handleFormSubmit` の最後で今日の日付を再セットし、`renderEntryTable()` を呼んで画面も同時に更新しています（第8章で詳しく扱います）。
* 後続の章で扱うフィルターや削除ボタンも、ここで紹介した変数や関数に追記していくだけで連携できる構造になっています。

まずはこの章のシンプルなコードで「仕組み」を理解し、慣れてきたら実際のソースと見比べながら、こうした工夫を少しずつ真似していきましょうね。

> 📝 `JSON.stringify` や `JSON.parse` を忘れてしまうと、localStorage に保存したデータがそのまま文字列になってしまいます。「ちゃんと配列に戻っているかな？」と心配になったら、`console.log` で途中経過をのぞいてみると安心です。
